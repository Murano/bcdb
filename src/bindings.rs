/* automatically generated by rust-bindgen */

#[link(name = "mdbx", kind = "static")]
#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::std::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::std::mem::transmute(self) }
}
impl <T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self { Self::new() }
}
impl <T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::std::marker::Copy for __BindgenUnionField<T> { }
impl <T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
pub const __GNUC_VA_LIST: ::std::os::raw::c_uint = 1;
pub const _STDINT_H: ::std::os::raw::c_uint = 1;
pub const _FEATURES_H: ::std::os::raw::c_uint = 1;
pub const _DEFAULT_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC11: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC99: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC95: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX_IMPLICITLY: ::std::os::raw::c_uint = 1;
pub const _POSIX_SOURCE: ::std::os::raw::c_uint = 1;
pub const _POSIX_C_SOURCE: ::std::os::raw::c_uint = 200809;
pub const __USE_POSIX: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX2: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199309: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199506: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K8: ::std::os::raw::c_uint = 1;
pub const _ATFILE_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_MISC: ::std::os::raw::c_uint = 1;
pub const __USE_ATFILE: ::std::os::raw::c_uint = 1;
pub const __USE_FORTIFY_LEVEL: ::std::os::raw::c_uint = 0;
pub const _STDC_PREDEF_H: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559__: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559_COMPLEX__: ::std::os::raw::c_uint = 1;
pub const __STDC_ISO_10646__: ::std::os::raw::c_uint = 201505;
pub const __STDC_NO_THREADS__: ::std::os::raw::c_uint = 1;
pub const __GNU_LIBRARY__: ::std::os::raw::c_uint = 6;
pub const __GLIBC__: ::std::os::raw::c_uint = 2;
pub const __GLIBC_MINOR__: ::std::os::raw::c_uint = 23;
pub const _SYS_CDEFS_H: ::std::os::raw::c_uint = 1;
pub const __WORDSIZE: ::std::os::raw::c_uint = 64;
pub const __WORDSIZE_TIME64_COMPAT32: ::std::os::raw::c_uint = 1;
pub const __SYSCALL_WORDSIZE: ::std::os::raw::c_uint = 64;
pub const _BITS_WCHAR_H: ::std::os::raw::c_uint = 1;
pub const INT8_MIN: ::std::os::raw::c_int = -128;
pub const INT16_MIN: ::std::os::raw::c_int = -32768;
pub const INT32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT8_MAX: ::std::os::raw::c_uint = 127;
pub const INT16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const UINT8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const INT_LEAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_LEAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_LEAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_LEAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_LEAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_LEAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const UINT_LEAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_LEAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_LEAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const INT_FAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_FAST16_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST32_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_FAST16_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const INT_FAST32_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_FAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_FAST16_MAX: ::std::os::raw::c_int = -1;
pub const UINT_FAST32_MAX: ::std::os::raw::c_int = -1;
pub const INTPTR_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INTPTR_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINTPTR_MAX: ::std::os::raw::c_int = -1;
pub const PTRDIFF_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const PTRDIFF_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const SIG_ATOMIC_MIN: ::std::os::raw::c_int = -2147483648;
pub const SIG_ATOMIC_MAX: ::std::os::raw::c_uint = 2147483647;
pub const SIZE_MAX: ::std::os::raw::c_int = -1;
pub const WINT_MIN: ::std::os::raw::c_uint = 0;
pub const WINT_MAX: ::std::os::raw::c_uint = 4294967295;
pub const _ERRNO_H: ::std::os::raw::c_uint = 1;
pub const EPERM: ::std::os::raw::c_uint = 1;
pub const ENOENT: ::std::os::raw::c_uint = 2;
pub const ESRCH: ::std::os::raw::c_uint = 3;
pub const EINTR: ::std::os::raw::c_uint = 4;
pub const EIO: ::std::os::raw::c_uint = 5;
pub const ENXIO: ::std::os::raw::c_uint = 6;
pub const E2BIG: ::std::os::raw::c_uint = 7;
pub const ENOEXEC: ::std::os::raw::c_uint = 8;
pub const EBADF: ::std::os::raw::c_uint = 9;
pub const ECHILD: ::std::os::raw::c_uint = 10;
pub const EAGAIN: ::std::os::raw::c_uint = 11;
pub const ENOMEM: ::std::os::raw::c_uint = 12;
pub const EACCES: ::std::os::raw::c_uint = 13;
pub const EFAULT: ::std::os::raw::c_uint = 14;
pub const ENOTBLK: ::std::os::raw::c_uint = 15;
pub const EBUSY: ::std::os::raw::c_uint = 16;
pub const EEXIST: ::std::os::raw::c_uint = 17;
pub const EXDEV: ::std::os::raw::c_uint = 18;
pub const ENODEV: ::std::os::raw::c_uint = 19;
pub const ENOTDIR: ::std::os::raw::c_uint = 20;
pub const EISDIR: ::std::os::raw::c_uint = 21;
pub const EINVAL: ::std::os::raw::c_uint = 22;
pub const ENFILE: ::std::os::raw::c_uint = 23;
pub const EMFILE: ::std::os::raw::c_uint = 24;
pub const ENOTTY: ::std::os::raw::c_uint = 25;
pub const ETXTBSY: ::std::os::raw::c_uint = 26;
pub const EFBIG: ::std::os::raw::c_uint = 27;
pub const ENOSPC: ::std::os::raw::c_uint = 28;
pub const ESPIPE: ::std::os::raw::c_uint = 29;
pub const EROFS: ::std::os::raw::c_uint = 30;
pub const EMLINK: ::std::os::raw::c_uint = 31;
pub const EPIPE: ::std::os::raw::c_uint = 32;
pub const EDOM: ::std::os::raw::c_uint = 33;
pub const ERANGE: ::std::os::raw::c_uint = 34;
pub const EDEADLK: ::std::os::raw::c_uint = 35;
pub const ENAMETOOLONG: ::std::os::raw::c_uint = 36;
pub const ENOLCK: ::std::os::raw::c_uint = 37;
pub const ENOSYS: ::std::os::raw::c_uint = 38;
pub const ENOTEMPTY: ::std::os::raw::c_uint = 39;
pub const ELOOP: ::std::os::raw::c_uint = 40;
pub const EWOULDBLOCK: ::std::os::raw::c_uint = 11;
pub const ENOMSG: ::std::os::raw::c_uint = 42;
pub const EIDRM: ::std::os::raw::c_uint = 43;
pub const ECHRNG: ::std::os::raw::c_uint = 44;
pub const EL2NSYNC: ::std::os::raw::c_uint = 45;
pub const EL3HLT: ::std::os::raw::c_uint = 46;
pub const EL3RST: ::std::os::raw::c_uint = 47;
pub const ELNRNG: ::std::os::raw::c_uint = 48;
pub const EUNATCH: ::std::os::raw::c_uint = 49;
pub const ENOCSI: ::std::os::raw::c_uint = 50;
pub const EL2HLT: ::std::os::raw::c_uint = 51;
pub const EBADE: ::std::os::raw::c_uint = 52;
pub const EBADR: ::std::os::raw::c_uint = 53;
pub const EXFULL: ::std::os::raw::c_uint = 54;
pub const ENOANO: ::std::os::raw::c_uint = 55;
pub const EBADRQC: ::std::os::raw::c_uint = 56;
pub const EBADSLT: ::std::os::raw::c_uint = 57;
pub const EDEADLOCK: ::std::os::raw::c_uint = 35;
pub const EBFONT: ::std::os::raw::c_uint = 59;
pub const ENOSTR: ::std::os::raw::c_uint = 60;
pub const ENODATA: ::std::os::raw::c_uint = 61;
pub const ETIME: ::std::os::raw::c_uint = 62;
pub const ENOSR: ::std::os::raw::c_uint = 63;
pub const ENONET: ::std::os::raw::c_uint = 64;
pub const ENOPKG: ::std::os::raw::c_uint = 65;
pub const EREMOTE: ::std::os::raw::c_uint = 66;
pub const ENOLINK: ::std::os::raw::c_uint = 67;
pub const EADV: ::std::os::raw::c_uint = 68;
pub const ESRMNT: ::std::os::raw::c_uint = 69;
pub const ECOMM: ::std::os::raw::c_uint = 70;
pub const EPROTO: ::std::os::raw::c_uint = 71;
pub const EMULTIHOP: ::std::os::raw::c_uint = 72;
pub const EDOTDOT: ::std::os::raw::c_uint = 73;
pub const EBADMSG: ::std::os::raw::c_uint = 74;
pub const EOVERFLOW: ::std::os::raw::c_uint = 75;
pub const ENOTUNIQ: ::std::os::raw::c_uint = 76;
pub const EBADFD: ::std::os::raw::c_uint = 77;
pub const EREMCHG: ::std::os::raw::c_uint = 78;
pub const ELIBACC: ::std::os::raw::c_uint = 79;
pub const ELIBBAD: ::std::os::raw::c_uint = 80;
pub const ELIBSCN: ::std::os::raw::c_uint = 81;
pub const ELIBMAX: ::std::os::raw::c_uint = 82;
pub const ELIBEXEC: ::std::os::raw::c_uint = 83;
pub const EILSEQ: ::std::os::raw::c_uint = 84;
pub const ERESTART: ::std::os::raw::c_uint = 85;
pub const ESTRPIPE: ::std::os::raw::c_uint = 86;
pub const EUSERS: ::std::os::raw::c_uint = 87;
pub const ENOTSOCK: ::std::os::raw::c_uint = 88;
pub const EDESTADDRREQ: ::std::os::raw::c_uint = 89;
pub const EMSGSIZE: ::std::os::raw::c_uint = 90;
pub const EPROTOTYPE: ::std::os::raw::c_uint = 91;
pub const ENOPROTOOPT: ::std::os::raw::c_uint = 92;
pub const EPROTONOSUPPORT: ::std::os::raw::c_uint = 93;
pub const ESOCKTNOSUPPORT: ::std::os::raw::c_uint = 94;
pub const EOPNOTSUPP: ::std::os::raw::c_uint = 95;
pub const EPFNOSUPPORT: ::std::os::raw::c_uint = 96;
pub const EAFNOSUPPORT: ::std::os::raw::c_uint = 97;
pub const EADDRINUSE: ::std::os::raw::c_uint = 98;
pub const EADDRNOTAVAIL: ::std::os::raw::c_uint = 99;
pub const ENETDOWN: ::std::os::raw::c_uint = 100;
pub const ENETUNREACH: ::std::os::raw::c_uint = 101;
pub const ENETRESET: ::std::os::raw::c_uint = 102;
pub const ECONNABORTED: ::std::os::raw::c_uint = 103;
pub const ECONNRESET: ::std::os::raw::c_uint = 104;
pub const ENOBUFS: ::std::os::raw::c_uint = 105;
pub const EISCONN: ::std::os::raw::c_uint = 106;
pub const ENOTCONN: ::std::os::raw::c_uint = 107;
pub const ESHUTDOWN: ::std::os::raw::c_uint = 108;
pub const ETOOMANYREFS: ::std::os::raw::c_uint = 109;
pub const ETIMEDOUT: ::std::os::raw::c_uint = 110;
pub const ECONNREFUSED: ::std::os::raw::c_uint = 111;
pub const EHOSTDOWN: ::std::os::raw::c_uint = 112;
pub const EHOSTUNREACH: ::std::os::raw::c_uint = 113;
pub const EALREADY: ::std::os::raw::c_uint = 114;
pub const EINPROGRESS: ::std::os::raw::c_uint = 115;
pub const ESTALE: ::std::os::raw::c_uint = 116;
pub const EUCLEAN: ::std::os::raw::c_uint = 117;
pub const ENOTNAM: ::std::os::raw::c_uint = 118;
pub const ENAVAIL: ::std::os::raw::c_uint = 119;
pub const EISNAM: ::std::os::raw::c_uint = 120;
pub const EREMOTEIO: ::std::os::raw::c_uint = 121;
pub const EDQUOT: ::std::os::raw::c_uint = 122;
pub const ENOMEDIUM: ::std::os::raw::c_uint = 123;
pub const EMEDIUMTYPE: ::std::os::raw::c_uint = 124;
pub const ECANCELED: ::std::os::raw::c_uint = 125;
pub const ENOKEY: ::std::os::raw::c_uint = 126;
pub const EKEYEXPIRED: ::std::os::raw::c_uint = 127;
pub const EKEYREVOKED: ::std::os::raw::c_uint = 128;
pub const EKEYREJECTED: ::std::os::raw::c_uint = 129;
pub const EOWNERDEAD: ::std::os::raw::c_uint = 130;
pub const ENOTRECOVERABLE: ::std::os::raw::c_uint = 131;
pub const ERFKILL: ::std::os::raw::c_uint = 132;
pub const EHWPOISON: ::std::os::raw::c_uint = 133;
pub const ENOTSUP: ::std::os::raw::c_uint = 95;
pub const _PTHREAD_H: ::std::os::raw::c_uint = 1;
pub const _ENDIAN_H: ::std::os::raw::c_uint = 1;
pub const __LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const __BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const __PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const __BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const __FLOAT_WORD_ORDER: ::std::os::raw::c_uint = 1234;
pub const LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const _BITS_BYTESWAP_H: ::std::os::raw::c_uint = 1;
pub const _BITS_TYPES_H: ::std::os::raw::c_uint = 1;
pub const _BITS_TYPESIZES_H: ::std::os::raw::c_uint = 1;
pub const __OFF_T_MATCHES_OFF64_T: ::std::os::raw::c_uint = 1;
pub const __INO_T_MATCHES_INO64_T: ::std::os::raw::c_uint = 1;
pub const __FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const _SCHED_H: ::std::os::raw::c_uint = 1;
pub const __time_t_defined: ::std::os::raw::c_uint = 1;
pub const __timespec_defined: ::std::os::raw::c_uint = 1;
pub const SCHED_OTHER: ::std::os::raw::c_uint = 0;
pub const SCHED_FIFO: ::std::os::raw::c_uint = 1;
pub const SCHED_RR: ::std::os::raw::c_uint = 2;
pub const __defined_schedparam: ::std::os::raw::c_uint = 1;
pub const __CPU_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const _TIME_H: ::std::os::raw::c_uint = 1;
pub const _BITS_TIME_H: ::std::os::raw::c_uint = 1;
pub const CLOCK_REALTIME: ::std::os::raw::c_uint = 0;
pub const CLOCK_MONOTONIC: ::std::os::raw::c_uint = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: ::std::os::raw::c_uint = 2;
pub const CLOCK_THREAD_CPUTIME_ID: ::std::os::raw::c_uint = 3;
pub const CLOCK_MONOTONIC_RAW: ::std::os::raw::c_uint = 4;
pub const CLOCK_REALTIME_COARSE: ::std::os::raw::c_uint = 5;
pub const CLOCK_MONOTONIC_COARSE: ::std::os::raw::c_uint = 6;
pub const CLOCK_BOOTTIME: ::std::os::raw::c_uint = 7;
pub const CLOCK_REALTIME_ALARM: ::std::os::raw::c_uint = 8;
pub const CLOCK_BOOTTIME_ALARM: ::std::os::raw::c_uint = 9;
pub const CLOCK_TAI: ::std::os::raw::c_uint = 11;
pub const TIMER_ABSTIME: ::std::os::raw::c_uint = 1;
pub const __clock_t_defined: ::std::os::raw::c_uint = 1;
pub const __clockid_t_defined: ::std::os::raw::c_uint = 1;
pub const __timer_t_defined: ::std::os::raw::c_uint = 1;
pub const TIME_UTC: ::std::os::raw::c_uint = 1;
pub const _XLOCALE_H: ::std::os::raw::c_uint = 1;
pub const _BITS_PTHREADTYPES_H: ::std::os::raw::c_uint = 1;
pub const __SIZEOF_PTHREAD_ATTR_T: ::std::os::raw::c_uint = 56;
pub const __SIZEOF_PTHREAD_MUTEX_T: ::std::os::raw::c_uint = 40;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: ::std::os::raw::c_uint = 4;
pub const __SIZEOF_PTHREAD_COND_T: ::std::os::raw::c_uint = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: ::std::os::raw::c_uint = 4;
pub const __SIZEOF_PTHREAD_RWLOCK_T: ::std::os::raw::c_uint = 56;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: ::std::os::raw::c_uint = 8;
pub const __SIZEOF_PTHREAD_BARRIER_T: ::std::os::raw::c_uint = 32;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: ::std::os::raw::c_uint = 4;
pub const __have_pthread_attr_t: ::std::os::raw::c_uint = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: ::std::os::raw::c_uint = 1;
pub const __PTHREAD_RWLOCK_INT_FLAGS_SHARED: ::std::os::raw::c_uint = 1;
pub const _BITS_SETJMP_H: ::std::os::raw::c_uint = 1;
pub const PTHREAD_ONCE_INIT: ::std::os::raw::c_uint = 0;
pub const PTHREAD_BARRIER_SERIAL_THREAD: ::std::os::raw::c_int = -1;
pub const _SYS_TYPES_H: ::std::os::raw::c_uint = 1;
pub const __BIT_TYPES_DEFINED__: ::std::os::raw::c_uint = 1;
pub const _SYS_SELECT_H: ::std::os::raw::c_uint = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\x00";
pub const _SIGSET_H_types: ::std::os::raw::c_uint = 1;
pub const _STRUCT_TIMEVAL: ::std::os::raw::c_uint = 1;
pub const FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const _SYS_SYSMACROS_H: ::std::os::raw::c_uint = 1;
pub const _SYS_UIO_H: ::std::os::raw::c_uint = 1;
pub const _BITS_UIO_H: ::std::os::raw::c_uint = 1;
pub const UIO_MAXIOV: ::std::os::raw::c_uint = 1024;
pub const HAVE_STRUCT_IOVEC: ::std::os::raw::c_uint = 1;
pub const MDBX_ENODATA: ::std::os::raw::c_uint = 61;
pub const MDBX_EINVAL: ::std::os::raw::c_uint = 22;
pub const MDBX_EACCESS: ::std::os::raw::c_uint = 13;
pub const MDBX_ENOMEM: ::std::os::raw::c_uint = 12;
pub const MDBX_EROFS: ::std::os::raw::c_uint = 30;
pub const MDBX_ENOSYS: ::std::os::raw::c_uint = 38;
pub const MDBX_EIO: ::std::os::raw::c_uint = 5;
pub const MDBX_EPERM: ::std::os::raw::c_uint = 1;
pub const MDBX_EINTR: ::std::os::raw::c_uint = 4;
pub const MDBX_VERSION_MAJOR: ::std::os::raw::c_uint = 0;
pub const MDBX_VERSION_MINOR: ::std::os::raw::c_uint = 0;
pub const MDBX_LOCKNAME: &'static [u8; 10usize] = b"/mdbx.lck\x00";
pub const MDBX_DATANAME: &'static [u8; 10usize] = b"/mdbx.dat\x00";
pub const MDBX_LOCK_SUFFIX: &'static [u8; 5usize] = b"-lck\x00";
pub const MDBX_MAXDATASIZE: ::std::os::raw::c_uint = 2147483647;
pub const MDBX_NOSUBDIR: ::std::os::raw::c_uint = 16384;
pub const MDBX_NOSYNC: ::std::os::raw::c_uint = 65536;
pub const MDBX_RDONLY: ::std::os::raw::c_uint = 131072;
pub const MDBX_NOMETASYNC: ::std::os::raw::c_uint = 262144;
pub const MDBX_WRITEMAP: ::std::os::raw::c_uint = 524288;
pub const MDBX_MAPASYNC: ::std::os::raw::c_uint = 1048576;
pub const MDBX_NOTLS: ::std::os::raw::c_uint = 2097152;
pub const MDBX_NOLOCK__UNSUPPORTED: ::std::os::raw::c_uint = 4194304;
pub const MDBX_NORDAHEAD: ::std::os::raw::c_uint = 8388608;
pub const MDBX_NOMEMINIT: ::std::os::raw::c_uint = 16777216;
pub const MDBX_COALESCE: ::std::os::raw::c_uint = 33554432;
pub const MDBX_LIFORECLAIM: ::std::os::raw::c_uint = 67108864;
pub const MDBX_UTTERLY_NOSYNC: ::std::os::raw::c_uint = 1114112;
pub const MDBX_PAGEPERTURB: ::std::os::raw::c_uint = 134217728;
pub const MDBX_REVERSEKEY: ::std::os::raw::c_uint = 2;
pub const MDBX_DUPSORT: ::std::os::raw::c_uint = 4;
pub const MDBX_INTEGERKEY: ::std::os::raw::c_uint = 8;
pub const MDBX_DUPFIXED: ::std::os::raw::c_uint = 16;
pub const MDBX_INTEGERDUP: ::std::os::raw::c_uint = 32;
pub const MDBX_REVERSEDUP: ::std::os::raw::c_uint = 64;
pub const MDBX_CREATE: ::std::os::raw::c_uint = 262144;
pub const MDBX_NOOVERWRITE: ::std::os::raw::c_uint = 16;
pub const MDBX_NODUPDATA: ::std::os::raw::c_uint = 32;
pub const MDBX_CURRENT: ::std::os::raw::c_uint = 64;
pub const MDBX_RESERVE: ::std::os::raw::c_uint = 65536;
pub const MDBX_APPEND: ::std::os::raw::c_uint = 131072;
pub const MDBX_APPENDDUP: ::std::os::raw::c_uint = 262144;
pub const MDBX_MULTIPLE: ::std::os::raw::c_uint = 524288;
pub const MDBX_TRYTXN: ::std::os::raw::c_uint = 268435456;
pub const MDBX_CP_COMPACT: ::std::os::raw::c_uint = 1;
pub const MDBX_SUCCESS: ::std::os::raw::c_uint = 0;
pub const MDBX_RESULT_FALSE: ::std::os::raw::c_uint = 0;
pub const MDBX_RESULT_TRUE: ::std::os::raw::c_int = -1;
pub const MDBX_KEYEXIST: ::std::os::raw::c_int = -30799;
pub const MDBX_NOTFOUND: ::std::os::raw::c_int = -30798;
pub const MDBX_PAGE_NOTFOUND: ::std::os::raw::c_int = -30797;
pub const MDBX_CORRUPTED: ::std::os::raw::c_int = -30796;
pub const MDBX_PANIC: ::std::os::raw::c_int = -30795;
pub const MDBX_VERSION_MISMATCH: ::std::os::raw::c_int = -30794;
pub const MDBX_INVALID: ::std::os::raw::c_int = -30793;
pub const MDBX_MAP_FULL: ::std::os::raw::c_int = -30792;
pub const MDBX_DBS_FULL: ::std::os::raw::c_int = -30791;
pub const MDBX_READERS_FULL: ::std::os::raw::c_int = -30790;
pub const MDBX_TXN_FULL: ::std::os::raw::c_int = -30788;
pub const MDBX_CURSOR_FULL: ::std::os::raw::c_int = -30787;
pub const MDBX_PAGE_FULL: ::std::os::raw::c_int = -30786;
pub const MDBX_MAP_RESIZED: ::std::os::raw::c_int = -30785;
pub const MDBX_INCOMPATIBLE: ::std::os::raw::c_int = -30784;
pub const MDBX_BAD_RSLOT: ::std::os::raw::c_int = -30783;
pub const MDBX_BAD_TXN: ::std::os::raw::c_int = -30782;
pub const MDBX_BAD_VALSIZE: ::std::os::raw::c_int = -30781;
pub const MDBX_BAD_DBI: ::std::os::raw::c_int = -30780;
pub const MDBX_PROBLEM: ::std::os::raw::c_int = -30779;
pub const MDBX_BUSY: ::std::os::raw::c_int = -30778;
pub const MDBX_LAST_ERRCODE: ::std::os::raw::c_int = -30778;
pub const MDBX_EMULTIVAL: ::std::os::raw::c_int = -30421;
pub const MDBX_EBADSIGN: ::std::os::raw::c_int = -30420;
pub const MDBX_WANNA_RECOVERY: ::std::os::raw::c_int = -30419;
pub const MDBX_EKEYMISMATCH: ::std::os::raw::c_int = -30418;
pub const MDBX_TOO_LARGE: ::std::os::raw::c_int = -30417;
pub const MDBX_THREAD_MISMATCH: ::std::os::raw::c_int = -30416;
pub const MDBX_TBL_DIRTY: ::std::os::raw::c_uint = 1;
pub const MDBX_TBL_STALE: ::std::os::raw::c_uint = 2;
pub const MDBX_TBL_NEW: ::std::os::raw::c_uint = 4;
pub const MDBX_DBG_ASSERT: ::std::os::raw::c_uint = 1;
pub const MDBX_DBG_PRINT: ::std::os::raw::c_uint = 2;
pub const MDBX_DBG_TRACE: ::std::os::raw::c_uint = 4;
pub const MDBX_DBG_EXTRA: ::std::os::raw::c_uint = 8;
pub const MDBX_DBG_AUDIT: ::std::os::raw::c_uint = 16;
pub const MDBX_DBG_JITTER: ::std::os::raw::c_uint = 32;
pub const MDBX_DBG_DUMP: ::std::os::raw::c_uint = 64;
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: f64,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(::std::mem::size_of::<max_align_t>() , 32usize , concat ! (
               "Size of: " , stringify ! ( max_align_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const max_align_t ) ) .
                __clang_max_align_nonce1 as * const _ as usize } , 0usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( max_align_t ) , "::" ,
                stringify ! ( __clang_max_align_nonce1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const max_align_t ) ) .
                __clang_max_align_nonce2 as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( max_align_t ) , "::" ,
                stringify ! ( __clang_max_align_nonce2 ) ));
}
impl Clone for max_align_t {
    fn clone(&self) -> Self { *self }
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
extern "C" {
    #[link_name = "_Z16__errno_location"]
    pub fn __errno_location() -> *mut ::std::os::raw::c_int;
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(::std::mem::size_of::<__fsid_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __fsid_t ) ));
    assert_eq! (::std::mem::align_of::<__fsid_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __fsid_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __fsid_t ) ) . __val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __fsid_t ) , "::" ,
                stringify ! ( __val ) ));
}
impl Clone for __fsid_t {
    fn clone(&self) -> Self { *self }
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type time_t = __time_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(::std::mem::size_of::<timespec>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timespec ) ));
    assert_eq! (::std::mem::align_of::<timespec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timespec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_nsec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_nsec ) ));
}
impl Clone for timespec {
    fn clone(&self) -> Self { *self }
}
pub type pid_t = __pid_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sched_param {
    pub __sched_priority: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sched_param() {
    assert_eq!(::std::mem::size_of::<sched_param>() , 4usize , concat ! (
               "Size of: " , stringify ! ( sched_param ) ));
    assert_eq! (::std::mem::align_of::<sched_param>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( sched_param ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sched_param ) ) . __sched_priority as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sched_param ) , "::" ,
                stringify ! ( __sched_priority ) ));
}
impl Clone for sched_param {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __sched_param {
    pub __sched_priority: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sched_param() {
    assert_eq!(::std::mem::size_of::<__sched_param>() , 4usize , concat ! (
               "Size of: " , stringify ! ( __sched_param ) ));
    assert_eq! (::std::mem::align_of::<__sched_param>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __sched_param ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sched_param ) ) . __sched_priority as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sched_param ) , "::"
                , stringify ! ( __sched_priority ) ));
}
impl Clone for __sched_param {
    fn clone(&self) -> Self { *self }
}
pub type __cpu_mask = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cpu_set_t {
    pub __bits: [__cpu_mask; 16usize],
}
#[test]
fn bindgen_test_layout_cpu_set_t() {
    assert_eq!(::std::mem::size_of::<cpu_set_t>() , 128usize , concat ! (
               "Size of: " , stringify ! ( cpu_set_t ) ));
    assert_eq! (::std::mem::align_of::<cpu_set_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( cpu_set_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_set_t ) ) . __bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cpu_set_t ) , "::" ,
                stringify ! ( __bits ) ));
}
impl Clone for cpu_set_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "_Z16__sched_cpucount"]
    pub fn __sched_cpucount(__setsize: usize, __setp: *const cpu_set_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z16__sched_cpualloc"]
    pub fn __sched_cpualloc(__count: usize) -> *mut cpu_set_t;
}
extern "C" {
    #[link_name = "_Z15__sched_cpufree"]
    pub fn __sched_cpufree(__set: *mut cpu_set_t);
}
extern "C" {
    #[link_name = "_Z14sched_setparam"]
    pub fn sched_setparam(__pid: __pid_t, __param: *const sched_param)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z14sched_getparam"]
    pub fn sched_getparam(__pid: __pid_t, __param: *mut sched_param)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z18sched_setscheduler"]
    pub fn sched_setscheduler(__pid: __pid_t, __policy: ::std::os::raw::c_int,
                              __param: *const sched_param)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z18sched_getscheduler"]
    pub fn sched_getscheduler(__pid: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z11sched_yield"]
    pub fn sched_yield() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z22sched_get_priority_max"]
    pub fn sched_get_priority_max(__algorithm: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z22sched_get_priority_min"]
    pub fn sched_get_priority_min(__algorithm: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z21sched_rr_get_interval"]
    pub fn sched_rr_get_interval(__pid: __pid_t, __t: *mut timespec)
     -> ::std::os::raw::c_int;
}
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(::std::mem::size_of::<tm>() , 56usize , concat ! (
               "Size of: " , stringify ! ( tm ) ));
    assert_eq! (::std::mem::align_of::<tm>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( tm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_sec as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_min as * const _ as usize } ,
                4usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_min ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_hour as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_hour ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_mday as * const _ as usize }
                , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_mday ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_mon as * const _ as usize } ,
                16usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_mon ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_year as * const _ as usize }
                , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_year ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_wday as * const _ as usize }
                , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_wday ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_yday as * const _ as usize }
                , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_yday ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_isdst as * const _ as usize }
                , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_isdst ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_gmtoff as * const _ as usize
                } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_gmtoff ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_zone as * const _ as usize }
                , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_zone ) ));
}
impl Clone for tm {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(::std::mem::size_of::<itimerspec>() , 32usize , concat ! (
               "Size of: " , stringify ! ( itimerspec ) ));
    assert_eq! (::std::mem::align_of::<itimerspec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( itimerspec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerspec ) ) . it_interval as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerspec ) , "::" ,
                stringify ! ( it_interval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerspec ) ) . it_value as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerspec ) , "::" ,
                stringify ! ( it_value ) ));
}
impl Clone for itimerspec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "_Z5clock"]
    pub fn clock() -> clock_t;
}
extern "C" {
    #[link_name = "_Z4time"]
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    #[link_name = "_Z8difftime"]
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    #[link_name = "_Z6mktime"]
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    #[link_name = "_Z8strftime"]
    pub fn strftime(__s: *mut ::std::os::raw::c_char, __maxsize: usize,
                    __format: *const ::std::os::raw::c_char, __tp: *const tm)
     -> usize;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(::std::mem::size_of::<__locale_struct>() , 232usize , concat !
               ( "Size of: " , stringify ! ( __locale_struct ) ));
    assert_eq! (::std::mem::align_of::<__locale_struct>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( __locale_struct ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __locales as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __locales ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __ctype_b as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __ctype_b ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __ctype_tolower as
                * const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __ctype_tolower ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __ctype_toupper as
                * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __ctype_toupper ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __names as * const
                _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __names ) ));
}
impl Clone for __locale_struct {
    fn clone(&self) -> Self { *self }
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    #[link_name = "_Z10strftime_l"]
    pub fn strftime_l(__s: *mut ::std::os::raw::c_char, __maxsize: usize,
                      __format: *const ::std::os::raw::c_char,
                      __tp: *const tm, __loc: __locale_t) -> usize;
}
extern "C" {
    #[link_name = "_Z6gmtime"]
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    #[link_name = "_Z9localtime"]
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    #[link_name = "_Z8gmtime_r"]
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    #[link_name = "_Z11localtime_r"]
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    #[link_name = "_Z7asctime"]
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "_Z5ctime"]
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "_Z9asctime_r"]
    pub fn asctime_r(__tp: *const tm, __buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "_Z7ctime_r"]
    pub fn ctime_r(__timer: *const time_t, __buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "_Z8__tzname"]
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    #[link_name = "_Z10__daylight"]
    pub static mut __daylight: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z10__timezone"]
    pub static mut __timezone: ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "_Z6tzname"]
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    #[link_name = "_Z5tzset"]
    pub fn tzset();
}
extern "C" {
    #[link_name = "_Z8daylight"]
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z8timezone"]
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "_Z5stime"]
    pub fn stime(__when: *const time_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z6timegm"]
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    #[link_name = "_Z9timelocal"]
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    #[link_name = "_Z6dysize"]
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z9nanosleep"]
    pub fn nanosleep(__requested_time: *const timespec,
                     __remaining: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z12clock_getres"]
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z13clock_gettime"]
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z13clock_settime"]
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z15clock_nanosleep"]
    pub fn clock_nanosleep(__clock_id: clockid_t,
                           __flags: ::std::os::raw::c_int,
                           __req: *const timespec, __rem: *mut timespec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z19clock_getcpuclockid"]
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z12timer_create"]
    pub fn timer_create(__clock_id: clockid_t, __evp: *mut sigevent,
                        __timerid: *mut timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z12timer_delete"]
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z13timer_settime"]
    pub fn timer_settime(__timerid: timer_t, __flags: ::std::os::raw::c_int,
                         __value: *const itimerspec,
                         __ovalue: *mut itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z13timer_gettime"]
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z16timer_getoverrun"]
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z12timespec_get"]
    pub fn timespec_get(__ts: *mut timespec, __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_attr_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 56usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_long>,
    pub bindgen_union_field: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(::std::mem::size_of::<pthread_attr_t>() , 56usize , concat ! (
               "Size of: " , stringify ! ( pthread_attr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_attr_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_attr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_attr_t ) ) . __size as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_attr_t ) , "::"
                , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_attr_t ) ) . __align as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_attr_t ) , "::"
                , stringify ! ( __align ) ));
}
impl Clone for pthread_attr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(::std::mem::size_of::<__pthread_internal_list>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( __pthread_internal_list ) ));
    assert_eq! (::std::mem::align_of::<__pthread_internal_list>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( __pthread_internal_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_internal_list ) ) . __prev as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_internal_list
                ) , "::" , stringify ! ( __prev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_internal_list ) ) . __next as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_internal_list
                ) , "::" , stringify ! ( __next ) ));
}
impl Clone for __pthread_internal_list {
    fn clone(&self) -> Self { *self }
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_mutex_t {
    pub __data: __BindgenUnionField<pthread_mutex_t___pthread_mutex_s>,
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 40usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_long>,
    pub bindgen_union_field: [u64; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_mutex_t___pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t___pthread_mutex_s() {
    assert_eq!(::std::mem::size_of::<pthread_mutex_t___pthread_mutex_s>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( pthread_mutex_t___pthread_mutex_s )
               ));
    assert_eq! (::std::mem::align_of::<pthread_mutex_t___pthread_mutex_s>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __lock as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __count as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __owner as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __owner ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __nusers as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __nusers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __kind as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __kind ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __spins as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __spins ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __elision as * const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __elision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __list as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __list ) ));
}
impl Clone for pthread_mutex_t___pthread_mutex_s {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(::std::mem::size_of::<pthread_mutex_t>() , 40usize , concat ! (
               "Size of: " , stringify ! ( pthread_mutex_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_mutex_t>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( pthread_mutex_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t ) ) . __data as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutex_t ) ,
                "::" , stringify ! ( __data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t ) ) . __size as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutex_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t ) ) . __align as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutex_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_mutex_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_mutexattr_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 4usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_int>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_mutexattr_t>() , 4usize , concat
               ! ( "Size of: " , stringify ! ( pthread_mutexattr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_mutexattr_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( pthread_mutexattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutexattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutexattr_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutexattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutexattr_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_mutexattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_cond_t {
    pub __data: __BindgenUnionField<pthread_cond_t__bindgen_ty_1>,
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 48usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_longlong>,
    pub bindgen_union_field: [u64; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_cond_t__bindgen_ty_1 {
    pub __lock: ::std::os::raw::c_int,
    pub __futex: ::std::os::raw::c_uint,
    pub __total_seq: ::std::os::raw::c_ulonglong,
    pub __wakeup_seq: ::std::os::raw::c_ulonglong,
    pub __woken_seq: ::std::os::raw::c_ulonglong,
    pub __mutex: *mut ::std::os::raw::c_void,
    pub __nwaiters: ::std::os::raw::c_uint,
    pub __broadcast_seq: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_cond_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<pthread_cond_t__bindgen_ty_1>() , 48usize
               , concat ! (
               "Size of: " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<pthread_cond_t__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_cond_t__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) . __lock
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __lock )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __futex as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __futex
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __total_seq as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __total_seq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __wakeup_seq as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __wakeup_seq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __woken_seq as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __woken_seq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __mutex as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __mutex
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __nwaiters as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __nwaiters ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __broadcast_seq as * const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __broadcast_seq ) ));
}
impl Clone for pthread_cond_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(::std::mem::size_of::<pthread_cond_t>() , 48usize , concat ! (
               "Size of: " , stringify ! ( pthread_cond_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_cond_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_cond_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t ) ) . __data as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::"
                , stringify ! ( __data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t ) ) . __size as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::"
                , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t ) ) . __align as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::"
                , stringify ! ( __align ) ));
}
impl Clone for pthread_cond_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_condattr_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 4usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_int>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_condattr_t>() , 4usize , concat !
               ( "Size of: " , stringify ! ( pthread_condattr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_condattr_t>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( pthread_condattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_condattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_condattr_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_condattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_condattr_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_condattr_t {
    fn clone(&self) -> Self { *self }
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_rwlock_t {
    pub __data: __BindgenUnionField<pthread_rwlock_t__bindgen_ty_1>,
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 56usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_long>,
    pub bindgen_union_field: [u64; 7usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_rwlock_t__bindgen_ty_1 {
    pub __lock: ::std::os::raw::c_int,
    pub __nr_readers: ::std::os::raw::c_uint,
    pub __readers_wakeup: ::std::os::raw::c_uint,
    pub __writer_wakeup: ::std::os::raw::c_uint,
    pub __nr_readers_queued: ::std::os::raw::c_uint,
    pub __nr_writers_queued: ::std::os::raw::c_uint,
    pub __writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<pthread_rwlock_t__bindgen_ty_1>() ,
               56usize , concat ! (
               "Size of: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<pthread_rwlock_t__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_rwlock_t__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __lock as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __lock
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __nr_readers as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __nr_readers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __readers_wakeup as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __readers_wakeup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __writer_wakeup as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __writer_wakeup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __nr_readers_queued as * const _ as usize } , 16usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __nr_readers_queued ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __nr_writers_queued as * const _ as usize } , 20usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __nr_writers_queued ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __writer as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __writer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __shared as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __shared ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __rwelision as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __rwelision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __pad1 as * const _ as usize } , 33usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __pad1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __pad2 as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __pad2
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __flags as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __flags ) ));
}
impl Clone for pthread_rwlock_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(::std::mem::size_of::<pthread_rwlock_t>() , 56usize , concat !
               ( "Size of: " , stringify ! ( pthread_rwlock_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_rwlock_t>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( pthread_rwlock_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t ) ) . __data as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlock_t ) ,
                "::" , stringify ! ( __data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t ) ) . __size as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlock_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t ) ) . __align as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlock_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_rwlock_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_rwlockattr_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 8usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_long>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_rwlockattr_t>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( pthread_rwlockattr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_rwlockattr_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( pthread_rwlockattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlockattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlockattr_t )
                , "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlockattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlockattr_t )
                , "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_rwlockattr_t {
    fn clone(&self) -> Self { *self }
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_barrier_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 32usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_long>,
    pub bindgen_union_field: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(::std::mem::size_of::<pthread_barrier_t>() , 32usize , concat !
               ( "Size of: " , stringify ! ( pthread_barrier_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_barrier_t>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( pthread_barrier_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrier_t ) ) . __size as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrier_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrier_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrier_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_barrier_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_barrierattr_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 4usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_int>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_barrierattr_t>() , 4usize ,
               concat ! ( "Size of: " , stringify ! ( pthread_barrierattr_t )
               ));
    assert_eq! (::std::mem::align_of::<pthread_barrierattr_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( pthread_barrierattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrierattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrierattr_t )
                , "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrierattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrierattr_t )
                , "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_barrierattr_t {
    fn clone(&self) -> Self { *self }
}
pub type __jmp_buf = [::std::os::raw::c_long; 8usize];
pub const PTHREAD_CREATE_JOINABLE: _bindgen_ty_1 =
    _bindgen_ty_1::PTHREAD_CREATE_JOINABLE;
pub const PTHREAD_CREATE_DETACHED: _bindgen_ty_1 =
    _bindgen_ty_1::PTHREAD_CREATE_DETACHED;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_1 {
    PTHREAD_CREATE_JOINABLE = 0,
    PTHREAD_CREATE_DETACHED = 1,
}
pub const PTHREAD_MUTEX_TIMED_NP: _bindgen_ty_2 =
    _bindgen_ty_2::PTHREAD_MUTEX_TIMED_NP;
pub const PTHREAD_MUTEX_RECURSIVE_NP: _bindgen_ty_2 =
    _bindgen_ty_2::PTHREAD_MUTEX_RECURSIVE_NP;
pub const PTHREAD_MUTEX_ERRORCHECK_NP: _bindgen_ty_2 =
    _bindgen_ty_2::PTHREAD_MUTEX_ERRORCHECK_NP;
pub const PTHREAD_MUTEX_ADAPTIVE_NP: _bindgen_ty_2 =
    _bindgen_ty_2::PTHREAD_MUTEX_ADAPTIVE_NP;
pub const PTHREAD_MUTEX_NORMAL: _bindgen_ty_2 =
    _bindgen_ty_2::PTHREAD_MUTEX_TIMED_NP;
pub const PTHREAD_MUTEX_RECURSIVE: _bindgen_ty_2 =
    _bindgen_ty_2::PTHREAD_MUTEX_RECURSIVE_NP;
pub const PTHREAD_MUTEX_ERRORCHECK: _bindgen_ty_2 =
    _bindgen_ty_2::PTHREAD_MUTEX_ERRORCHECK_NP;
pub const PTHREAD_MUTEX_DEFAULT: _bindgen_ty_2 =
    _bindgen_ty_2::PTHREAD_MUTEX_TIMED_NP;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_2 {
    PTHREAD_MUTEX_TIMED_NP = 0,
    PTHREAD_MUTEX_RECURSIVE_NP = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP = 3,
}
pub const PTHREAD_MUTEX_STALLED: _bindgen_ty_3 =
    _bindgen_ty_3::PTHREAD_MUTEX_STALLED;
pub const PTHREAD_MUTEX_STALLED_NP: _bindgen_ty_3 =
    _bindgen_ty_3::PTHREAD_MUTEX_STALLED;
pub const PTHREAD_MUTEX_ROBUST: _bindgen_ty_3 =
    _bindgen_ty_3::PTHREAD_MUTEX_ROBUST;
pub const PTHREAD_MUTEX_ROBUST_NP: _bindgen_ty_3 =
    _bindgen_ty_3::PTHREAD_MUTEX_ROBUST;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_3 {
    PTHREAD_MUTEX_STALLED = 0,
    PTHREAD_MUTEX_ROBUST = 1,
}
pub const PTHREAD_PRIO_NONE: _bindgen_ty_4 = _bindgen_ty_4::PTHREAD_PRIO_NONE;
pub const PTHREAD_PRIO_INHERIT: _bindgen_ty_4 =
    _bindgen_ty_4::PTHREAD_PRIO_INHERIT;
pub const PTHREAD_PRIO_PROTECT: _bindgen_ty_4 =
    _bindgen_ty_4::PTHREAD_PRIO_PROTECT;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_4 {
    PTHREAD_PRIO_NONE = 0,
    PTHREAD_PRIO_INHERIT = 1,
    PTHREAD_PRIO_PROTECT = 2,
}
pub const PTHREAD_RWLOCK_PREFER_READER_NP: _bindgen_ty_5 =
    _bindgen_ty_5::PTHREAD_RWLOCK_PREFER_READER_NP;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NP: _bindgen_ty_5 =
    _bindgen_ty_5::PTHREAD_RWLOCK_PREFER_WRITER_NP;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP: _bindgen_ty_5 =
    _bindgen_ty_5::PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP;
pub const PTHREAD_RWLOCK_DEFAULT_NP: _bindgen_ty_5 =
    _bindgen_ty_5::PTHREAD_RWLOCK_PREFER_READER_NP;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_5 {
    PTHREAD_RWLOCK_PREFER_READER_NP = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP = 2,
}
pub const PTHREAD_INHERIT_SCHED: _bindgen_ty_6 =
    _bindgen_ty_6::PTHREAD_INHERIT_SCHED;
pub const PTHREAD_EXPLICIT_SCHED: _bindgen_ty_6 =
    _bindgen_ty_6::PTHREAD_EXPLICIT_SCHED;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_6 {
    PTHREAD_INHERIT_SCHED = 0,
    PTHREAD_EXPLICIT_SCHED = 1,
}
pub const PTHREAD_SCOPE_SYSTEM: _bindgen_ty_7 =
    _bindgen_ty_7::PTHREAD_SCOPE_SYSTEM;
pub const PTHREAD_SCOPE_PROCESS: _bindgen_ty_7 =
    _bindgen_ty_7::PTHREAD_SCOPE_PROCESS;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_7 {
    PTHREAD_SCOPE_SYSTEM = 0,
    PTHREAD_SCOPE_PROCESS = 1,
}
pub const PTHREAD_PROCESS_PRIVATE: _bindgen_ty_8 =
    _bindgen_ty_8::PTHREAD_PROCESS_PRIVATE;
pub const PTHREAD_PROCESS_SHARED: _bindgen_ty_8 =
    _bindgen_ty_8::PTHREAD_PROCESS_SHARED;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_8 {
    PTHREAD_PROCESS_PRIVATE = 0,
    PTHREAD_PROCESS_SHARED = 1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _pthread_cleanup_buffer {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                  *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __canceltype: ::std::os::raw::c_int,
    pub __prev: *mut _pthread_cleanup_buffer,
}
#[test]
fn bindgen_test_layout__pthread_cleanup_buffer() {
    assert_eq!(::std::mem::size_of::<_pthread_cleanup_buffer>() , 32usize ,
               concat ! (
               "Size of: " , stringify ! ( _pthread_cleanup_buffer ) ));
    assert_eq! (::std::mem::align_of::<_pthread_cleanup_buffer>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _pthread_cleanup_buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _pthread_cleanup_buffer ) ) . __routine
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _pthread_cleanup_buffer
                ) , "::" , stringify ! ( __routine ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _pthread_cleanup_buffer ) ) . __arg as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _pthread_cleanup_buffer
                ) , "::" , stringify ! ( __arg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _pthread_cleanup_buffer ) ) .
                __canceltype as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _pthread_cleanup_buffer
                ) , "::" , stringify ! ( __canceltype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _pthread_cleanup_buffer ) ) . __prev as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _pthread_cleanup_buffer
                ) , "::" , stringify ! ( __prev ) ));
}
impl Clone for _pthread_cleanup_buffer {
    fn clone(&self) -> Self { *self }
}
pub const PTHREAD_CANCEL_ENABLE: _bindgen_ty_9 =
    _bindgen_ty_9::PTHREAD_CANCEL_ENABLE;
pub const PTHREAD_CANCEL_DISABLE: _bindgen_ty_9 =
    _bindgen_ty_9::PTHREAD_CANCEL_DISABLE;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_9 {
    PTHREAD_CANCEL_ENABLE = 0,
    PTHREAD_CANCEL_DISABLE = 1,
}
pub const PTHREAD_CANCEL_DEFERRED: _bindgen_ty_10 =
    _bindgen_ty_10::PTHREAD_CANCEL_DEFERRED;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: _bindgen_ty_10 =
    _bindgen_ty_10::PTHREAD_CANCEL_ASYNCHRONOUS;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_10 {
    PTHREAD_CANCEL_DEFERRED = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS = 1,
}
extern "C" {
    #[link_name = "_Z14pthread_create"]
    pub fn pthread_create(__newthread: *mut pthread_t,
                          __attr: *const pthread_attr_t,
                          __start_routine:
                              ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                             *mut ::std::os::raw::c_void)
                                                        ->
                                                            *mut ::std::os::raw::c_void>,
                          __arg: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z12pthread_exit"]
    pub fn pthread_exit(__retval: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "_Z12pthread_join"]
    pub fn pthread_join(__th: pthread_t,
                        __thread_return: *mut *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z14pthread_detach"]
    pub fn pthread_detach(__th: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z12pthread_self"]
    pub fn pthread_self() -> pthread_t;
}
extern "C" {
    #[link_name = "_Z13pthread_equal"]
    pub fn pthread_equal(__thread1: pthread_t, __thread2: pthread_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z17pthread_attr_init"]
    pub fn pthread_attr_init(__attr: *mut pthread_attr_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z20pthread_attr_destroy"]
    pub fn pthread_attr_destroy(__attr: *mut pthread_attr_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z27pthread_attr_getdetachstate"]
    pub fn pthread_attr_getdetachstate(__attr: *const pthread_attr_t,
                                       __detachstate:
                                           *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z27pthread_attr_setdetachstate"]
    pub fn pthread_attr_setdetachstate(__attr: *mut pthread_attr_t,
                                       __detachstate: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z25pthread_attr_getguardsize"]
    pub fn pthread_attr_getguardsize(__attr: *const pthread_attr_t,
                                     __guardsize: *mut usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z25pthread_attr_setguardsize"]
    pub fn pthread_attr_setguardsize(__attr: *mut pthread_attr_t,
                                     __guardsize: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z26pthread_attr_getschedparam"]
    pub fn pthread_attr_getschedparam(__attr: *const pthread_attr_t,
                                      __param: *mut sched_param)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z26pthread_attr_setschedparam"]
    pub fn pthread_attr_setschedparam(__attr: *mut pthread_attr_t,
                                      __param: *const sched_param)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z27pthread_attr_getschedpolicy"]
    pub fn pthread_attr_getschedpolicy(__attr: *const pthread_attr_t,
                                       __policy: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z27pthread_attr_setschedpolicy"]
    pub fn pthread_attr_setschedpolicy(__attr: *mut pthread_attr_t,
                                       __policy: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z28pthread_attr_getinheritsched"]
    pub fn pthread_attr_getinheritsched(__attr: *const pthread_attr_t,
                                        __inherit: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z28pthread_attr_setinheritsched"]
    pub fn pthread_attr_setinheritsched(__attr: *mut pthread_attr_t,
                                        __inherit: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z21pthread_attr_getscope"]
    pub fn pthread_attr_getscope(__attr: *const pthread_attr_t,
                                 __scope: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z21pthread_attr_setscope"]
    pub fn pthread_attr_setscope(__attr: *mut pthread_attr_t,
                                 __scope: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z25pthread_attr_getstackaddr"]
    pub fn pthread_attr_getstackaddr(__attr: *const pthread_attr_t,
                                     __stackaddr:
                                         *mut *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z25pthread_attr_setstackaddr"]
    pub fn pthread_attr_setstackaddr(__attr: *mut pthread_attr_t,
                                     __stackaddr: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z25pthread_attr_getstacksize"]
    pub fn pthread_attr_getstacksize(__attr: *const pthread_attr_t,
                                     __stacksize: *mut usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z25pthread_attr_setstacksize"]
    pub fn pthread_attr_setstacksize(__attr: *mut pthread_attr_t,
                                     __stacksize: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z21pthread_attr_getstack"]
    pub fn pthread_attr_getstack(__attr: *const pthread_attr_t,
                                 __stackaddr:
                                     *mut *mut ::std::os::raw::c_void,
                                 __stacksize: *mut usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z21pthread_attr_setstack"]
    pub fn pthread_attr_setstack(__attr: *mut pthread_attr_t,
                                 __stackaddr: *mut ::std::os::raw::c_void,
                                 __stacksize: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z21pthread_setschedparam"]
    pub fn pthread_setschedparam(__target_thread: pthread_t,
                                 __policy: ::std::os::raw::c_int,
                                 __param: *const sched_param)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z21pthread_getschedparam"]
    pub fn pthread_getschedparam(__target_thread: pthread_t,
                                 __policy: *mut ::std::os::raw::c_int,
                                 __param: *mut sched_param)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z20pthread_setschedprio"]
    pub fn pthread_setschedprio(__target_thread: pthread_t,
                                __prio: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z12pthread_once"]
    pub fn pthread_once(__once_control: *mut pthread_once_t,
                        __init_routine:
                            ::std::option::Option<unsafe extern "C" fn()>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z22pthread_setcancelstate"]
    pub fn pthread_setcancelstate(__state: ::std::os::raw::c_int,
                                  __oldstate: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z21pthread_setcanceltype"]
    pub fn pthread_setcanceltype(__type: ::std::os::raw::c_int,
                                 __oldtype: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z14pthread_cancel"]
    pub fn pthread_cancel(__th: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z18pthread_testcancel"]
    pub fn pthread_testcancel();
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __pthread_unwind_buf_t {
    pub __cancel_jmp_buf: [__pthread_unwind_buf_t__bindgen_ty_1; 1usize],
    pub __pad: [*mut ::std::os::raw::c_void; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __pthread_unwind_buf_t__bindgen_ty_1 {
    pub __cancel_jmp_buf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___pthread_unwind_buf_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<__pthread_unwind_buf_t__bindgen_ty_1>() ,
               72usize , concat ! (
               "Size of: " , stringify ! (
               __pthread_unwind_buf_t__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<__pthread_unwind_buf_t__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                __pthread_unwind_buf_t__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_unwind_buf_t__bindgen_ty_1 ) )
                . __cancel_jmp_buf as * const _ as usize } , 0usize , concat !
                (
                "Alignment of field: " , stringify ! (
                __pthread_unwind_buf_t__bindgen_ty_1 ) , "::" , stringify ! (
                __cancel_jmp_buf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_unwind_buf_t__bindgen_ty_1 ) )
                . __mask_was_saved as * const _ as usize } , 64usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                __pthread_unwind_buf_t__bindgen_ty_1 ) , "::" , stringify ! (
                __mask_was_saved ) ));
}
impl Clone for __pthread_unwind_buf_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout___pthread_unwind_buf_t() {
    assert_eq!(::std::mem::size_of::<__pthread_unwind_buf_t>() , 104usize ,
               concat ! ( "Size of: " , stringify ! ( __pthread_unwind_buf_t )
               ));
    assert_eq! (::std::mem::align_of::<__pthread_unwind_buf_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( __pthread_unwind_buf_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_unwind_buf_t ) ) .
                __cancel_jmp_buf as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_unwind_buf_t
                ) , "::" , stringify ! ( __cancel_jmp_buf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_unwind_buf_t ) ) . __pad as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_unwind_buf_t
                ) , "::" , stringify ! ( __pad ) ));
}
impl Clone for __pthread_unwind_buf_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __pthread_cleanup_frame {
    pub __cancel_routine: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                         *mut ::std::os::raw::c_void)>,
    pub __cancel_arg: *mut ::std::os::raw::c_void,
    pub __do_it: ::std::os::raw::c_int,
    pub __cancel_type: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___pthread_cleanup_frame() {
    assert_eq!(::std::mem::size_of::<__pthread_cleanup_frame>() , 24usize ,
               concat ! (
               "Size of: " , stringify ! ( __pthread_cleanup_frame ) ));
    assert_eq! (::std::mem::align_of::<__pthread_cleanup_frame>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( __pthread_cleanup_frame ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_cleanup_frame ) ) .
                __cancel_routine as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_cleanup_frame
                ) , "::" , stringify ! ( __cancel_routine ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_cleanup_frame ) ) .
                __cancel_arg as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_cleanup_frame
                ) , "::" , stringify ! ( __cancel_arg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_cleanup_frame ) ) . __do_it as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_cleanup_frame
                ) , "::" , stringify ! ( __do_it ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_cleanup_frame ) ) .
                __cancel_type as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_cleanup_frame
                ) , "::" , stringify ! ( __cancel_type ) ));
}
impl Clone for __pthread_cleanup_frame {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "_Z25__pthread_register_cancel"]
    pub fn __pthread_register_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    #[link_name = "_Z27__pthread_unregister_cancel"]
    pub fn __pthread_unregister_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    #[link_name = "_Z21__pthread_unwind_next"]
    pub fn __pthread_unwind_next(__buf: *mut __pthread_unwind_buf_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __jmp_buf_tag {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "_Z11__sigsetjmp"]
    pub fn __sigsetjmp(__env: *mut __jmp_buf_tag,
                       __savemask: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z18pthread_mutex_init"]
    pub fn pthread_mutex_init(__mutex: *mut pthread_mutex_t,
                              __mutexattr: *const pthread_mutexattr_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z21pthread_mutex_destroy"]
    pub fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z21pthread_mutex_trylock"]
    pub fn pthread_mutex_trylock(__mutex: *mut pthread_mutex_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z18pthread_mutex_lock"]
    pub fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z23pthread_mutex_timedlock"]
    pub fn pthread_mutex_timedlock(__mutex: *mut pthread_mutex_t,
                                   __abstime: *const timespec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z20pthread_mutex_unlock"]
    pub fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z28pthread_mutex_getprioceiling"]
    pub fn pthread_mutex_getprioceiling(__mutex: *const pthread_mutex_t,
                                        __prioceiling:
                                            *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z28pthread_mutex_setprioceiling"]
    pub fn pthread_mutex_setprioceiling(__mutex: *mut pthread_mutex_t,
                                        __prioceiling: ::std::os::raw::c_int,
                                        __old_ceiling:
                                            *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z24pthread_mutex_consistent"]
    pub fn pthread_mutex_consistent(__mutex: *mut pthread_mutex_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z22pthread_mutexattr_init"]
    pub fn pthread_mutexattr_init(__attr: *mut pthread_mutexattr_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z25pthread_mutexattr_destroy"]
    pub fn pthread_mutexattr_destroy(__attr: *mut pthread_mutexattr_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z28pthread_mutexattr_getpshared"]
    pub fn pthread_mutexattr_getpshared(__attr: *const pthread_mutexattr_t,
                                        __pshared: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z28pthread_mutexattr_setpshared"]
    pub fn pthread_mutexattr_setpshared(__attr: *mut pthread_mutexattr_t,
                                        __pshared: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z25pthread_mutexattr_gettype"]
    pub fn pthread_mutexattr_gettype(__attr: *const pthread_mutexattr_t,
                                     __kind: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z25pthread_mutexattr_settype"]
    pub fn pthread_mutexattr_settype(__attr: *mut pthread_mutexattr_t,
                                     __kind: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z29pthread_mutexattr_getprotocol"]
    pub fn pthread_mutexattr_getprotocol(__attr: *const pthread_mutexattr_t,
                                         __protocol:
                                             *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z29pthread_mutexattr_setprotocol"]
    pub fn pthread_mutexattr_setprotocol(__attr: *mut pthread_mutexattr_t,
                                         __protocol: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z32pthread_mutexattr_getprioceiling"]
    pub fn pthread_mutexattr_getprioceiling(__attr:
                                                *const pthread_mutexattr_t,
                                            __prioceiling:
                                                *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z32pthread_mutexattr_setprioceiling"]
    pub fn pthread_mutexattr_setprioceiling(__attr: *mut pthread_mutexattr_t,
                                            __prioceiling:
                                                ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z27pthread_mutexattr_getrobust"]
    pub fn pthread_mutexattr_getrobust(__attr: *const pthread_mutexattr_t,
                                       __robustness:
                                           *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z27pthread_mutexattr_setrobust"]
    pub fn pthread_mutexattr_setrobust(__attr: *mut pthread_mutexattr_t,
                                       __robustness: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z19pthread_rwlock_init"]
    pub fn pthread_rwlock_init(__rwlock: *mut pthread_rwlock_t,
                               __attr: *const pthread_rwlockattr_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z22pthread_rwlock_destroy"]
    pub fn pthread_rwlock_destroy(__rwlock: *mut pthread_rwlock_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z21pthread_rwlock_rdlock"]
    pub fn pthread_rwlock_rdlock(__rwlock: *mut pthread_rwlock_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z24pthread_rwlock_tryrdlock"]
    pub fn pthread_rwlock_tryrdlock(__rwlock: *mut pthread_rwlock_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z26pthread_rwlock_timedrdlock"]
    pub fn pthread_rwlock_timedrdlock(__rwlock: *mut pthread_rwlock_t,
                                      __abstime: *const timespec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z21pthread_rwlock_wrlock"]
    pub fn pthread_rwlock_wrlock(__rwlock: *mut pthread_rwlock_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z24pthread_rwlock_trywrlock"]
    pub fn pthread_rwlock_trywrlock(__rwlock: *mut pthread_rwlock_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z26pthread_rwlock_timedwrlock"]
    pub fn pthread_rwlock_timedwrlock(__rwlock: *mut pthread_rwlock_t,
                                      __abstime: *const timespec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z21pthread_rwlock_unlock"]
    pub fn pthread_rwlock_unlock(__rwlock: *mut pthread_rwlock_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z23pthread_rwlockattr_init"]
    pub fn pthread_rwlockattr_init(__attr: *mut pthread_rwlockattr_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z26pthread_rwlockattr_destroy"]
    pub fn pthread_rwlockattr_destroy(__attr: *mut pthread_rwlockattr_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z29pthread_rwlockattr_getpshared"]
    pub fn pthread_rwlockattr_getpshared(__attr: *const pthread_rwlockattr_t,
                                         __pshared:
                                             *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z29pthread_rwlockattr_setpshared"]
    pub fn pthread_rwlockattr_setpshared(__attr: *mut pthread_rwlockattr_t,
                                         __pshared: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z29pthread_rwlockattr_getkind_np"]
    pub fn pthread_rwlockattr_getkind_np(__attr: *const pthread_rwlockattr_t,
                                         __pref: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z29pthread_rwlockattr_setkind_np"]
    pub fn pthread_rwlockattr_setkind_np(__attr: *mut pthread_rwlockattr_t,
                                         __pref: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z17pthread_cond_init"]
    pub fn pthread_cond_init(__cond: *mut pthread_cond_t,
                             __cond_attr: *const pthread_condattr_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z20pthread_cond_destroy"]
    pub fn pthread_cond_destroy(__cond: *mut pthread_cond_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z19pthread_cond_signal"]
    pub fn pthread_cond_signal(__cond: *mut pthread_cond_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z22pthread_cond_broadcast"]
    pub fn pthread_cond_broadcast(__cond: *mut pthread_cond_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z17pthread_cond_wait"]
    pub fn pthread_cond_wait(__cond: *mut pthread_cond_t,
                             __mutex: *mut pthread_mutex_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z22pthread_cond_timedwait"]
    pub fn pthread_cond_timedwait(__cond: *mut pthread_cond_t,
                                  __mutex: *mut pthread_mutex_t,
                                  __abstime: *const timespec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z21pthread_condattr_init"]
    pub fn pthread_condattr_init(__attr: *mut pthread_condattr_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z24pthread_condattr_destroy"]
    pub fn pthread_condattr_destroy(__attr: *mut pthread_condattr_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z27pthread_condattr_getpshared"]
    pub fn pthread_condattr_getpshared(__attr: *const pthread_condattr_t,
                                       __pshared: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z27pthread_condattr_setpshared"]
    pub fn pthread_condattr_setpshared(__attr: *mut pthread_condattr_t,
                                       __pshared: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z25pthread_condattr_getclock"]
    pub fn pthread_condattr_getclock(__attr: *const pthread_condattr_t,
                                     __clock_id: *mut __clockid_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z25pthread_condattr_setclock"]
    pub fn pthread_condattr_setclock(__attr: *mut pthread_condattr_t,
                                     __clock_id: __clockid_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z17pthread_spin_init"]
    pub fn pthread_spin_init(__lock: *mut pthread_spinlock_t,
                             __pshared: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z20pthread_spin_destroy"]
    pub fn pthread_spin_destroy(__lock: *mut pthread_spinlock_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z17pthread_spin_lock"]
    pub fn pthread_spin_lock(__lock: *mut pthread_spinlock_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z20pthread_spin_trylock"]
    pub fn pthread_spin_trylock(__lock: *mut pthread_spinlock_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z19pthread_spin_unlock"]
    pub fn pthread_spin_unlock(__lock: *mut pthread_spinlock_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z20pthread_barrier_init"]
    pub fn pthread_barrier_init(__barrier: *mut pthread_barrier_t,
                                __attr: *const pthread_barrierattr_t,
                                __count: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z23pthread_barrier_destroy"]
    pub fn pthread_barrier_destroy(__barrier: *mut pthread_barrier_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z20pthread_barrier_wait"]
    pub fn pthread_barrier_wait(__barrier: *mut pthread_barrier_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z24pthread_barrierattr_init"]
    pub fn pthread_barrierattr_init(__attr: *mut pthread_barrierattr_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z27pthread_barrierattr_destroy"]
    pub fn pthread_barrierattr_destroy(__attr: *mut pthread_barrierattr_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z30pthread_barrierattr_getpshared"]
    pub fn pthread_barrierattr_getpshared(__attr:
                                              *const pthread_barrierattr_t,
                                          __pshared:
                                              *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z30pthread_barrierattr_setpshared"]
    pub fn pthread_barrierattr_setpshared(__attr: *mut pthread_barrierattr_t,
                                          __pshared: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z18pthread_key_create"]
    pub fn pthread_key_create(__key: *mut pthread_key_t,
                              __destr_function:
                                  ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                 *mut ::std::os::raw::c_void)>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z18pthread_key_delete"]
    pub fn pthread_key_delete(__key: pthread_key_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z19pthread_getspecific"]
    pub fn pthread_getspecific(__key: pthread_key_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "_Z19pthread_setspecific"]
    pub fn pthread_setspecific(__key: pthread_key_t,
                               __pointer: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z21pthread_getcpuclockid"]
    pub fn pthread_getcpuclockid(__thread_id: pthread_t,
                                 __clock_id: *mut __clockid_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z14pthread_atfork"]
    pub fn pthread_atfork(__prepare:
                              ::std::option::Option<unsafe extern "C" fn()>,
                          __parent:
                              ::std::option::Option<unsafe extern "C" fn()>,
                          __child:
                              ::std::option::Option<unsafe extern "C" fn()>)
     -> ::std::os::raw::c_int;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulong;
pub type register_t = ::std::os::raw::c_long;
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(::std::mem::size_of::<__sigset_t>() , 128usize , concat ! (
               "Size of: " , stringify ! ( __sigset_t ) ));
    assert_eq! (::std::mem::align_of::<__sigset_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __sigset_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sigset_t ) ) . __val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sigset_t ) , "::" ,
                stringify ! ( __val ) ));
}
impl Clone for __sigset_t {
    fn clone(&self) -> Self { *self }
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(::std::mem::size_of::<timeval>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timeval ) ));
    assert_eq! (::std::mem::align_of::<timeval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timeval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_usec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_usec ) ));
}
impl Clone for timeval {
    fn clone(&self) -> Self { *self }
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(::std::mem::size_of::<fd_set>() , 128usize , concat ! (
               "Size of: " , stringify ! ( fd_set ) ));
    assert_eq! (::std::mem::align_of::<fd_set>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( fd_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fd_set ) ) . __fds_bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( fd_set ) , "::" ,
                stringify ! ( __fds_bits ) ));
}
impl Clone for fd_set {
    fn clone(&self) -> Self { *self }
}
pub type fd_mask = __fd_mask;
extern "C" {
    #[link_name = "_Z6select"]
    pub fn select(__nfds: ::std::os::raw::c_int, __readfds: *mut fd_set,
                  __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                  __timeout: *mut timeval) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z7pselect"]
    pub fn pselect(__nfds: ::std::os::raw::c_int, __readfds: *mut fd_set,
                   __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                   __timeout: *const timespec, __sigmask: *const __sigset_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z13gnu_dev_major"]
    pub fn gnu_dev_major(__dev: ::std::os::raw::c_ulonglong)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "_Z13gnu_dev_minor"]
    pub fn gnu_dev_minor(__dev: ::std::os::raw::c_ulonglong)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "_Z15gnu_dev_makedev"]
    pub fn gnu_dev_makedev(__major: ::std::os::raw::c_uint,
                           __minor: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_ulonglong;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: usize,
}
#[test]
fn bindgen_test_layout_iovec() {
    assert_eq!(::std::mem::size_of::<iovec>() , 16usize , concat ! (
               "Size of: " , stringify ! ( iovec ) ));
    assert_eq! (::std::mem::align_of::<iovec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( iovec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const iovec ) ) . iov_base as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( iovec ) , "::" ,
                stringify ! ( iov_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const iovec ) ) . iov_len as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( iovec ) , "::" ,
                stringify ! ( iov_len ) ));
}
impl Clone for iovec {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "_Z5readv"]
    pub fn readv(__fd: ::std::os::raw::c_int, __iovec: *const iovec,
                 __count: ::std::os::raw::c_int) -> isize;
}
extern "C" {
    #[link_name = "_Z6writev"]
    pub fn writev(__fd: ::std::os::raw::c_int, __iovec: *const iovec,
                  __count: ::std::os::raw::c_int) -> isize;
}
extern "C" {
    #[link_name = "_Z6preadv"]
    pub fn preadv(__fd: ::std::os::raw::c_int, __iovec: *const iovec,
                  __count: ::std::os::raw::c_int, __offset: __off_t) -> isize;
}
extern "C" {
    #[link_name = "_Z7pwritev"]
    pub fn pwritev(__fd: ::std::os::raw::c_int, __iovec: *const iovec,
                   __count: ::std::os::raw::c_int, __offset: __off_t)
     -> isize;
}
pub type mdbx_filehandle_t = ::std::os::raw::c_int;
pub type mdbx_pid_t = pid_t;
pub type mdbx_tid_t = pthread_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mdbx_version_info {
    pub major: u8,
    pub minor: u8,
    pub release: u16,
    pub revision: u32,
    pub git: mdbx_version_info__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mdbx_version_info__bindgen_ty_1 {
    pub datetime: *const ::std::os::raw::c_char,
    pub tree: *const ::std::os::raw::c_char,
    pub commit: *const ::std::os::raw::c_char,
    pub describe: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_mdbx_version_info__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<mdbx_version_info__bindgen_ty_1>() ,
               32usize , concat ! (
               "Size of: " , stringify ! ( mdbx_version_info__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<mdbx_version_info__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                mdbx_version_info__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mdbx_version_info__bindgen_ty_1 ) ) .
                datetime as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                mdbx_version_info__bindgen_ty_1 ) , "::" , stringify ! (
                datetime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mdbx_version_info__bindgen_ty_1 ) ) .
                tree as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                mdbx_version_info__bindgen_ty_1 ) , "::" , stringify ! ( tree
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mdbx_version_info__bindgen_ty_1 ) ) .
                commit as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                mdbx_version_info__bindgen_ty_1 ) , "::" , stringify ! (
                commit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mdbx_version_info__bindgen_ty_1 ) ) .
                describe as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                mdbx_version_info__bindgen_ty_1 ) , "::" , stringify ! (
                describe ) ));
}
impl Clone for mdbx_version_info__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_mdbx_version_info() {
    assert_eq!(::std::mem::size_of::<mdbx_version_info>() , 40usize , concat !
               ( "Size of: " , stringify ! ( mdbx_version_info ) ));
    assert_eq! (::std::mem::align_of::<mdbx_version_info>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( mdbx_version_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mdbx_version_info ) ) . major as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mdbx_version_info ) ,
                "::" , stringify ! ( major ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mdbx_version_info ) ) . minor as * const
                _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( mdbx_version_info ) ,
                "::" , stringify ! ( minor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mdbx_version_info ) ) . release as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( mdbx_version_info ) ,
                "::" , stringify ! ( release ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mdbx_version_info ) ) . revision as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( mdbx_version_info ) ,
                "::" , stringify ! ( revision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mdbx_version_info ) ) . git as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mdbx_version_info ) ,
                "::" , stringify ! ( git ) ));
}
impl Clone for mdbx_version_info {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mdbx_build_info {
    pub datetime: *const ::std::os::raw::c_char,
    pub target: *const ::std::os::raw::c_char,
    pub options: *const ::std::os::raw::c_char,
    pub compiler: *const ::std::os::raw::c_char,
    pub flags: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_mdbx_build_info() {
    assert_eq!(::std::mem::size_of::<mdbx_build_info>() , 40usize , concat ! (
               "Size of: " , stringify ! ( mdbx_build_info ) ));
    assert_eq! (::std::mem::align_of::<mdbx_build_info>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( mdbx_build_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mdbx_build_info ) ) . datetime as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mdbx_build_info ) ,
                "::" , stringify ! ( datetime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mdbx_build_info ) ) . target as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mdbx_build_info ) ,
                "::" , stringify ! ( target ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mdbx_build_info ) ) . options as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mdbx_build_info ) ,
                "::" , stringify ! ( options ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mdbx_build_info ) ) . compiler as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mdbx_build_info ) ,
                "::" , stringify ! ( compiler ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mdbx_build_info ) ) . flags as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( mdbx_build_info ) ,
                "::" , stringify ! ( flags ) ));
}
impl Clone for mdbx_build_info {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "_Z12mdbx_version"]
    pub static mdbx_version: mdbx_version_info;
}
extern "C" {
    #[link_name = "_Z10mdbx_build"]
    pub static mdbx_build: mdbx_build_info;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MDBX_env {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MDBX_txn {
    _unused: [u8; 0],
}
pub type MDBX_dbi = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MDBX_cursor {
    _unused: [u8; 0],
}
pub type MDBX_val = iovec;
pub type MDBX_cmp_func =
    ::std::option::Option<unsafe extern "C" fn(a: *const MDBX_val,
                                               b: *const MDBX_val)
                              -> ::std::os::raw::c_int>;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum MDBX_cursor_op {
    MDBX_FIRST = 0,
    MDBX_FIRST_DUP = 1,
    MDBX_GET_BOTH = 2,
    MDBX_GET_BOTH_RANGE = 3,
    MDBX_GET_CURRENT = 4,
    MDBX_GET_MULTIPLE = 5,
    MDBX_LAST = 6,
    MDBX_LAST_DUP = 7,
    MDBX_NEXT = 8,
    MDBX_NEXT_DUP = 9,
    MDBX_NEXT_MULTIPLE = 10,
    MDBX_NEXT_NODUP = 11,
    MDBX_PREV = 12,
    MDBX_PREV_DUP = 13,
    MDBX_PREV_NODUP = 14,
    MDBX_SET = 15,
    MDBX_SET_KEY = 16,
    MDBX_SET_RANGE = 17,
    MDBX_PREV_MULTIPLE = 18,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct MDBX_stat {
    pub ms_psize: u32,
    pub ms_depth: u32,
    pub ms_branch_pages: u64,
    pub ms_leaf_pages: u64,
    pub ms_overflow_pages: u64,
    pub ms_entries: u64,
}
#[test]
fn bindgen_test_layout_MDBX_stat() {
    assert_eq!(::std::mem::size_of::<MDBX_stat>() , 40usize , concat ! (
               "Size of: " , stringify ! ( MDBX_stat ) ));
    assert_eq! (::std::mem::align_of::<MDBX_stat>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( MDBX_stat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MDBX_stat ) ) . ms_psize as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( MDBX_stat ) , "::" ,
                stringify ! ( ms_psize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MDBX_stat ) ) . ms_depth as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( MDBX_stat ) , "::" ,
                stringify ! ( ms_depth ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MDBX_stat ) ) . ms_branch_pages as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( MDBX_stat ) , "::" ,
                stringify ! ( ms_branch_pages ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MDBX_stat ) ) . ms_leaf_pages as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( MDBX_stat ) , "::" ,
                stringify ! ( ms_leaf_pages ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MDBX_stat ) ) . ms_overflow_pages as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( MDBX_stat ) , "::" ,
                stringify ! ( ms_overflow_pages ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MDBX_stat ) ) . ms_entries as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( MDBX_stat ) , "::" ,
                stringify ! ( ms_entries ) ));
}
impl Clone for MDBX_stat {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct MDBX_envinfo {
    pub mi_geo: MDBX_envinfo__bindgen_ty_1,
    pub mi_mapsize: u64,
    pub mi_last_pgno: u64,
    pub mi_recent_txnid: u64,
    pub mi_latter_reader_txnid: u64,
    pub mi_meta0_txnid: u64,
    pub mi_meta0_sign: u64,
    pub mi_meta1_txnid: u64,
    pub mi_meta1_sign: u64,
    pub mi_meta2_txnid: u64,
    pub mi_meta2_sign: u64,
    pub mi_maxreaders: u32,
    pub mi_numreaders: u32,
    pub mi_dxb_pagesize: u32,
    pub mi_sys_pagesize: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct MDBX_envinfo__bindgen_ty_1 {
    pub lower: u64,
    pub upper: u64,
    pub current: u64,
    pub shrink: u64,
    pub grow: u64,
}
#[test]
fn bindgen_test_layout_MDBX_envinfo__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<MDBX_envinfo__bindgen_ty_1>() , 40usize ,
               concat ! (
               "Size of: " , stringify ! ( MDBX_envinfo__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<MDBX_envinfo__bindgen_ty_1>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( MDBX_envinfo__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MDBX_envinfo__bindgen_ty_1 ) ) . lower as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                MDBX_envinfo__bindgen_ty_1 ) , "::" , stringify ! ( lower )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MDBX_envinfo__bindgen_ty_1 ) ) . upper as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                MDBX_envinfo__bindgen_ty_1 ) , "::" , stringify ! ( upper )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MDBX_envinfo__bindgen_ty_1 ) ) . current
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                MDBX_envinfo__bindgen_ty_1 ) , "::" , stringify ! ( current )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MDBX_envinfo__bindgen_ty_1 ) ) . shrink
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                MDBX_envinfo__bindgen_ty_1 ) , "::" , stringify ! ( shrink )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MDBX_envinfo__bindgen_ty_1 ) ) . grow as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                MDBX_envinfo__bindgen_ty_1 ) , "::" , stringify ! ( grow ) ));
}
impl Clone for MDBX_envinfo__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_MDBX_envinfo() {
    assert_eq!(::std::mem::size_of::<MDBX_envinfo>() , 136usize , concat ! (
               "Size of: " , stringify ! ( MDBX_envinfo ) ));
    assert_eq! (::std::mem::align_of::<MDBX_envinfo>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( MDBX_envinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MDBX_envinfo ) ) . mi_geo as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( MDBX_envinfo ) , "::" ,
                stringify ! ( mi_geo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MDBX_envinfo ) ) . mi_mapsize as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( MDBX_envinfo ) , "::" ,
                stringify ! ( mi_mapsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MDBX_envinfo ) ) . mi_last_pgno as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( MDBX_envinfo ) , "::" ,
                stringify ! ( mi_last_pgno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MDBX_envinfo ) ) . mi_recent_txnid as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( MDBX_envinfo ) , "::" ,
                stringify ! ( mi_recent_txnid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MDBX_envinfo ) ) . mi_latter_reader_txnid
                as * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( MDBX_envinfo ) , "::" ,
                stringify ! ( mi_latter_reader_txnid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MDBX_envinfo ) ) . mi_meta0_txnid as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( MDBX_envinfo ) , "::" ,
                stringify ! ( mi_meta0_txnid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MDBX_envinfo ) ) . mi_meta0_sign as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( MDBX_envinfo ) , "::" ,
                stringify ! ( mi_meta0_sign ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MDBX_envinfo ) ) . mi_meta1_txnid as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( MDBX_envinfo ) , "::" ,
                stringify ! ( mi_meta1_txnid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MDBX_envinfo ) ) . mi_meta1_sign as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( MDBX_envinfo ) , "::" ,
                stringify ! ( mi_meta1_sign ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MDBX_envinfo ) ) . mi_meta2_txnid as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( MDBX_envinfo ) , "::" ,
                stringify ! ( mi_meta2_txnid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MDBX_envinfo ) ) . mi_meta2_sign as *
                const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( MDBX_envinfo ) , "::" ,
                stringify ! ( mi_meta2_sign ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MDBX_envinfo ) ) . mi_maxreaders as *
                const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( MDBX_envinfo ) , "::" ,
                stringify ! ( mi_maxreaders ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MDBX_envinfo ) ) . mi_numreaders as *
                const _ as usize } , 124usize , concat ! (
                "Alignment of field: " , stringify ! ( MDBX_envinfo ) , "::" ,
                stringify ! ( mi_numreaders ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MDBX_envinfo ) ) . mi_dxb_pagesize as *
                const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( MDBX_envinfo ) , "::" ,
                stringify ! ( mi_dxb_pagesize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MDBX_envinfo ) ) . mi_sys_pagesize as *
                const _ as usize } , 132usize , concat ! (
                "Alignment of field: " , stringify ! ( MDBX_envinfo ) , "::" ,
                stringify ! ( mi_sys_pagesize ) ));
}
impl Clone for MDBX_envinfo {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "_Z13mdbx_strerror"]
    pub fn mdbx_strerror(errnum: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "_Z15mdbx_strerror_r"]
    pub fn mdbx_strerror_r(errnum: ::std::os::raw::c_int,
                           buf: *mut ::std::os::raw::c_char, buflen: usize)
     -> *const ::std::os::raw::c_char;
}

extern "C" {
    #[link_name = "_Z13mdbx_env_open"]
    pub fn mdbx_env_open(env: *mut MDBX_env,
                         path: *const ::std::os::raw::c_char,
                         flags: ::std::os::raw::c_uint, mode: mode_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z16mdbx_env_open_ex"]
    pub fn mdbx_env_open_ex(env: *mut MDBX_env,
                            path: *const ::std::os::raw::c_char,
                            flags: ::std::os::raw::c_uint, mode: mode_t,
                            exclusive: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z13mdbx_env_copy"]
    pub fn mdbx_env_copy(env: *mut MDBX_env,
                         path: *const ::std::os::raw::c_char,
                         flags: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z16mdbx_env_copy2fd"]
    pub fn mdbx_env_copy2fd(env: *mut MDBX_env, fd: mdbx_filehandle_t,
                            flags: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z13mdbx_env_stat"]
    pub fn mdbx_env_stat(env: *mut MDBX_env, stat: *mut MDBX_stat,
                         bytes: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z13mdbx_env_info"]
    pub fn mdbx_env_info(env: *mut MDBX_env, info: *mut MDBX_envinfo,
                         bytes: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z13mdbx_env_sync"]
    pub fn mdbx_env_sync(env: *mut MDBX_env, force: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z14mdbx_env_close"]
    pub fn mdbx_env_close(env: *mut MDBX_env);
}
extern "C" {
    #[link_name = "_Z18mdbx_env_set_flags"]
    pub fn mdbx_env_set_flags(env: *mut MDBX_env,
                              flags: ::std::os::raw::c_uint,
                              onoff: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z18mdbx_env_get_flags"]
    pub fn mdbx_env_get_flags(env: *mut MDBX_env,
                              flags: *mut ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z17mdbx_env_get_path"]
    pub fn mdbx_env_get_path(env: *mut MDBX_env,
                             path: *mut *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z15mdbx_env_get_fd"]
    pub fn mdbx_env_get_fd(env: *mut MDBX_env, fd: *mut mdbx_filehandle_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z20mdbx_env_set_mapsize"]
    pub fn mdbx_env_set_mapsize(env: *mut MDBX_env, size: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z21mdbx_env_set_geometry"]
    pub fn mdbx_env_set_geometry(env: *mut MDBX_env, size_lower: isize,
                                 size_now: isize, size_upper: isize,
                                 growth_step: isize, shrink_threshold: isize,
                                 pagesize: isize) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z23mdbx_env_set_maxreaders"]
    pub fn mdbx_env_set_maxreaders(env: *mut MDBX_env,
                                   readers: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z23mdbx_env_get_maxreaders"]
    pub fn mdbx_env_get_maxreaders(env: *mut MDBX_env,
                                   readers: *mut ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z19mdbx_env_set_maxdbs"]
    pub fn mdbx_env_set_maxdbs(env: *mut MDBX_env, dbs: MDBX_dbi)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z23mdbx_env_get_maxkeysize"]
    pub fn mdbx_env_get_maxkeysize(env: *mut MDBX_env)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z19mdbx_get_maxkeysize"]
    pub fn mdbx_get_maxkeysize(pagesize: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z20mdbx_env_set_userctx"]
    pub fn mdbx_env_set_userctx(env: *mut MDBX_env,
                                ctx: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z20mdbx_env_get_userctx"]
    pub fn mdbx_env_get_userctx(env: *mut MDBX_env)
     -> *mut ::std::os::raw::c_void;
}
pub type MDBX_assert_func =
    ::std::option::Option<unsafe extern "C" fn(env: *const MDBX_env,
                                               msg:
                                                   *const ::std::os::raw::c_char,
                                               function:
                                                   *const ::std::os::raw::c_char,
                                               line: ::std::os::raw::c_uint)>;
extern "C" {
    #[link_name = "_Z19mdbx_env_set_assert"]
    pub fn mdbx_env_set_assert(env: *mut MDBX_env, func: MDBX_assert_func)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z14mdbx_txn_begin"]
    pub fn mdbx_txn_begin(env: *mut MDBX_env, parent: *mut MDBX_txn,
                          flags: ::std::os::raw::c_uint,
                          txn: *mut *mut MDBX_txn) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z12mdbx_txn_env"]
    pub fn mdbx_txn_env(txn: *mut MDBX_txn) -> *mut MDBX_env;
}
extern "C" {
    #[link_name = "_Z11mdbx_txn_id"]
    pub fn mdbx_txn_id(txn: *mut MDBX_txn) -> u64;
}
extern "C" {
    #[link_name = "_Z15mdbx_txn_commit"]
    pub fn mdbx_txn_commit(txn: *mut MDBX_txn) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z14mdbx_txn_abort"]
    pub fn mdbx_txn_abort(txn: *mut MDBX_txn) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z14mdbx_txn_reset"]
    pub fn mdbx_txn_reset(txn: *mut MDBX_txn) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z14mdbx_txn_renew"]
    pub fn mdbx_txn_renew(txn: *mut MDBX_txn) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z16mdbx_dbi_open_ex"]
    pub fn mdbx_dbi_open_ex(txn: *mut MDBX_txn,
                            name: *const ::std::os::raw::c_char,
                            flags: ::std::os::raw::c_uint, dbi: *mut MDBX_dbi,
                            keycmp: MDBX_cmp_func, datacmp: MDBX_cmp_func)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z13mdbx_dbi_open"]
    pub fn mdbx_dbi_open(txn: *mut MDBX_txn,
                         name: *const ::std::os::raw::c_char,
                         flags: ::std::os::raw::c_uint, dbi: *mut MDBX_dbi)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z13mdbx_dbi_stat"]
    pub fn mdbx_dbi_stat(txn: *mut MDBX_txn, dbi: MDBX_dbi,
                         stat: *mut MDBX_stat, bytes: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z17mdbx_dbi_flags_ex"]
    pub fn mdbx_dbi_flags_ex(txn: *mut MDBX_txn, dbi: MDBX_dbi,
                             flags: *mut ::std::os::raw::c_uint,
                             state: *mut ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z14mdbx_dbi_flags"]
    pub fn mdbx_dbi_flags(txn: *mut MDBX_txn, dbi: MDBX_dbi,
                          flags: *mut ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z14mdbx_dbi_close"]
    pub fn mdbx_dbi_close(env: *mut MDBX_env, dbi: MDBX_dbi)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z9mdbx_drop"]
    pub fn mdbx_drop(txn: *mut MDBX_txn, dbi: MDBX_dbi,
                     del: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z8mdbx_get"]
    pub fn mdbx_get(txn: *mut MDBX_txn, dbi: MDBX_dbi, key: *mut MDBX_val,
                    data: *mut MDBX_val) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z8mdbx_put"]
    pub fn mdbx_put(txn: *mut MDBX_txn, dbi: MDBX_dbi, key: *mut MDBX_val,
                    data: *mut MDBX_val, flags: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z8mdbx_del"]
    pub fn mdbx_del(txn: *mut MDBX_txn, dbi: MDBX_dbi, key: *mut MDBX_val,
                    data: *mut MDBX_val) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z16mdbx_cursor_open"]
    pub fn mdbx_cursor_open(txn: *mut MDBX_txn, dbi: MDBX_dbi,
                            cursor: *mut *mut MDBX_cursor)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z17mdbx_cursor_close"]
    pub fn mdbx_cursor_close(cursor: *mut MDBX_cursor);
}
extern "C" {
    #[link_name = "_Z17mdbx_cursor_renew"]
    pub fn mdbx_cursor_renew(txn: *mut MDBX_txn, cursor: *mut MDBX_cursor)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z15mdbx_cursor_txn"]
    pub fn mdbx_cursor_txn(cursor: *mut MDBX_cursor) -> *mut MDBX_txn;
}
extern "C" {
    #[link_name = "_Z15mdbx_cursor_dbi"]
    pub fn mdbx_cursor_dbi(cursor: *mut MDBX_cursor) -> MDBX_dbi;
}
extern "C" {
    #[link_name = "_Z15mdbx_cursor_get"]
    pub fn mdbx_cursor_get(cursor: *mut MDBX_cursor, key: *mut MDBX_val,
                           data: *mut MDBX_val, op: MDBX_cursor_op)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z15mdbx_cursor_put"]
    pub fn mdbx_cursor_put(cursor: *mut MDBX_cursor, key: *mut MDBX_val,
                           data: *mut MDBX_val, flags: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z15mdbx_cursor_del"]
    pub fn mdbx_cursor_del(cursor: *mut MDBX_cursor,
                           flags: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z17mdbx_cursor_count"]
    pub fn mdbx_cursor_count(cursor: *mut MDBX_cursor, countp: *mut usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z8mdbx_cmp"]
    pub fn mdbx_cmp(txn: *mut MDBX_txn, dbi: MDBX_dbi, a: *const MDBX_val,
                    b: *const MDBX_val) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z9mdbx_dcmp"]
    pub fn mdbx_dcmp(txn: *mut MDBX_txn, dbi: MDBX_dbi, a: *const MDBX_val,
                     b: *const MDBX_val) -> ::std::os::raw::c_int;
}
pub type MDBX_msg_func =
    ::std::option::Option<unsafe extern "C" fn(msg:
                                                   *const ::std::os::raw::c_char,
                                               ctx:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
extern "C" {
    #[link_name = "_Z16mdbx_reader_list"]
    pub fn mdbx_reader_list(env: *mut MDBX_env, func: MDBX_msg_func,
                            ctx: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z17mdbx_reader_check"]
    pub fn mdbx_reader_check(env: *mut MDBX_env,
                             dead: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z9mdbx_dkey"]
    pub fn mdbx_dkey(key: *const MDBX_val, buf: *const ::std::os::raw::c_char,
                     bufsize: usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "_Z17mdbx_env_close_ex"]
    pub fn mdbx_env_close_ex(env: *mut MDBX_env,
                             dont_sync: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z22mdbx_env_set_syncbytes"]
    pub fn mdbx_env_set_syncbytes(env: *mut MDBX_env, bytes: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z18mdbx_txn_straggler"]
    pub fn mdbx_txn_straggler(txn: *mut MDBX_txn,
                              percent: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
pub type MDBX_oom_func =
    ::std::option::Option<unsafe extern "C" fn(env: *mut MDBX_env,
                                               pid: ::std::os::raw::c_int,
                                               tid: mdbx_tid_t, txn: u64,
                                               gap: ::std::os::raw::c_uint,
                                               retry: ::std::os::raw::c_int)
                              -> ::std::os::raw::c_int>;
extern "C" {
    #[link_name = "_Z20mdbx_env_set_oomfunc"]
    pub fn mdbx_env_set_oomfunc(env: *mut MDBX_env, oom_func: MDBX_oom_func)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z20mdbx_env_get_oomfunc"]
    pub fn mdbx_env_get_oomfunc(env: *mut MDBX_env) -> MDBX_oom_func;
}
pub type MDBX_debug_func =
    ::std::option::Option<unsafe extern "C" fn(type_: ::std::os::raw::c_int,
                                               function:
                                                   *const ::std::os::raw::c_char,
                                               line: ::std::os::raw::c_int,
                                               msg:
                                                   *const ::std::os::raw::c_char,
                                               args: *mut __va_list_tag)>;
extern "C" {
    #[link_name = "_Z16mdbx_setup_debug"]
    pub fn mdbx_setup_debug(flags: ::std::os::raw::c_int,
                            logger: MDBX_debug_func) -> ::std::os::raw::c_int;
}
pub type MDBX_pgvisitor_func =
    ::std::option::Option<unsafe extern "C" fn(pgno: u64,
                                               pgnumber:
                                                   ::std::os::raw::c_uint,
                                               ctx:
                                                   *mut ::std::os::raw::c_void,
                                               dbi:
                                                   *const ::std::os::raw::c_char,
                                               type_:
                                                   *const ::std::os::raw::c_char,
                                               nentries: usize,
                                               payload_bytes: usize,
                                               header_bytes: usize,
                                               unused_bytes: usize)
                              -> ::std::os::raw::c_int>;
extern "C" {
    #[link_name = "_Z15mdbx_env_pgwalk"]
    pub fn mdbx_env_pgwalk(txn: *mut MDBX_txn, visitor: MDBX_pgvisitor_func,
                           ctx: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mdbx_canary {
    pub x: u64,
    pub y: u64,
    pub z: u64,
    pub v: u64,
}
#[test]
fn bindgen_test_layout_mdbx_canary() {
    assert_eq!(::std::mem::size_of::<mdbx_canary>() , 32usize , concat ! (
               "Size of: " , stringify ! ( mdbx_canary ) ));
    assert_eq! (::std::mem::align_of::<mdbx_canary>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mdbx_canary ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mdbx_canary ) ) . x as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mdbx_canary ) , "::" ,
                stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mdbx_canary ) ) . y as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mdbx_canary ) , "::" ,
                stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mdbx_canary ) ) . z as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mdbx_canary ) , "::" ,
                stringify ! ( z ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mdbx_canary ) ) . v as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mdbx_canary ) , "::" ,
                stringify ! ( v ) ));
}
impl Clone for mdbx_canary {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "_Z15mdbx_canary_put"]
    pub fn mdbx_canary_put(txn: *mut MDBX_txn, canary: *const mdbx_canary)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z15mdbx_canary_get"]
    pub fn mdbx_canary_get(txn: *mut MDBX_txn, canary: *mut mdbx_canary)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z15mdbx_cursor_eof"]
    pub fn mdbx_cursor_eof(mc: *mut MDBX_cursor) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z20mdbx_cursor_on_first"]
    pub fn mdbx_cursor_on_first(mc: *mut MDBX_cursor)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z19mdbx_cursor_on_last"]
    pub fn mdbx_cursor_on_last(mc: *mut MDBX_cursor) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z12mdbx_replace"]
    pub fn mdbx_replace(txn: *mut MDBX_txn, dbi: MDBX_dbi, key: *mut MDBX_val,
                        new_data: *mut MDBX_val, old_data: *mut MDBX_val,
                        flags: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z11mdbx_get_ex"]
    pub fn mdbx_get_ex(txn: *mut MDBX_txn, dbi: MDBX_dbi, key: *mut MDBX_val,
                       data: *mut MDBX_val, values_count: *mut usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z13mdbx_is_dirty"]
    pub fn mdbx_is_dirty(txn: *const MDBX_txn,
                         ptr: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z17mdbx_dbi_sequence"]
    pub fn mdbx_dbi_sequence(txn: *mut MDBX_txn, dbi: MDBX_dbi,
                             result: *mut u64, increment: u64)
     -> ::std::os::raw::c_int;
}
pub type mdbx_attr_t = uint_fast64_t;
extern "C" {
    #[link_name = "_Z20mdbx_cursor_put_attr"]
    pub fn mdbx_cursor_put_attr(cursor: *mut MDBX_cursor, key: *mut MDBX_val,
                                data: *mut MDBX_val, attr: mdbx_attr_t,
                                flags: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z13mdbx_put_attr"]
    pub fn mdbx_put_attr(txn: *mut MDBX_txn, dbi: MDBX_dbi,
                         key: *mut MDBX_val, data: *mut MDBX_val,
                         attr: mdbx_attr_t, flags: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z13mdbx_set_attr"]
    pub fn mdbx_set_attr(txn: *mut MDBX_txn, dbi: MDBX_dbi,
                         key: *mut MDBX_val, data: *mut MDBX_val,
                         attr: mdbx_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z20mdbx_cursor_get_attr"]
    pub fn mdbx_cursor_get_attr(mc: *mut MDBX_cursor, key: *mut MDBX_val,
                                data: *mut MDBX_val,
                                attrptr: *mut mdbx_attr_t, op: MDBX_cursor_op)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_Z13mdbx_get_attr"]
    pub fn mdbx_get_attr(txn: *mut MDBX_txn, dbi: MDBX_dbi,
                         key: *mut MDBX_val, data: *mut MDBX_val,
                         attrptr: *mut mdbx_attr_t) -> ::std::os::raw::c_int;
}

pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(::std::mem::size_of::<__va_list_tag>() , 24usize , concat ! (
               "Size of: " , stringify ! ( __va_list_tag ) ));
    assert_eq! (::std::mem::align_of::<__va_list_tag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __va_list_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . gp_offset as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( gp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . fp_offset as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( fp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . overflow_arg_area as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( overflow_arg_area ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . reg_save_area as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( reg_save_area ) ));
}
impl Clone for __va_list_tag {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __locale_data {
    pub _address: u8,
}
impl Clone for __locale_data {
    fn clone(&self) -> Self { *self }
}
